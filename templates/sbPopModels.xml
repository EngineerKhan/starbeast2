<beast version="2.0" namespace="beast.app.beauti:beast.core:beast.evolution.branchratemodel:beast.evolution.speciation:beast.evolution.tree.coalescent:beast.core.util:beast.evolution.nuc:beast.evolution.operators:beast.evolution.sitemodel:beast.evolution.substitutionmodel:beast.evolution.likelihood:beast.evolution:beast.math.distributions">
	<!-- population model priors -->
	<mergewith point="sbPopModelTemplates">
		<!-- Analytical integration of per-branch effective population sizes -->
		<subtemplate id="AnalyticalPopulationSizeIntegration" class="starbeast2.DummyModel" mainid="constantPopIOModel.$(n)">
<![CDATA[
			<plugin id="constantPopIOModel.$(n)" spec="starbeast2.DummyModel"/>

			<parameter name="alpha" id="popShape.$(n)" lower="0.0" value="3.0" estimate="false"/>
			<parameter name="mean" id="popMean.$(n)" lower="0.0" value="1.0" estimate="true"/>

			<distribution id="popShapePrior.$(n)" spec="beast.math.distributions.Prior" x="@popShape.$(n)">
				<distr spec="beast.math.distributions.Uniform" lower="0.0" upper="10000.0"/>
			</distribution>

			<distribution id="popMeanPrior.$(n)" spec="beast.math.distributions.Prior" x="@popMean.$(n)">
				<distr spec="beast.math.distributions.OneOnX"/>
			</distribution>

			<operator id="popShapeScale.$(n)" parameter="@popShape.$(n)" scaleFactor="0.75" spec="ScaleOperator" weight="1.0"/>
			<operator id="popMeanScale.$(n)" parameter="@popMean.$(n)" scaleFactor="0.75" spec="ScaleOperator" weight="1.0"/>
]]>

			<connect srcID="constantPopIOModel.Species" targetID="popModelBridge.Species" inputName="childModel"/>

			<connect srcID="popShape.Species" targetID="speciescoalescent" inputName="populationShape" if="inposterior(constantPopIOModel.Species)"/>
			<connect srcID="popMean.Species" targetID="speciescoalescent" inputName="populationMean" if="inposterior(constantPopIOModel.Species)"/>

			<connect srcID="popShape.Species" targetID="state" inputName="stateNode" if="inposterior(constantPopIOModel.Species) and popShape.Species/estimate=true"/>
			<connect srcID="popMean.Species" targetID="state" inputName="stateNode" if="inposterior(constantPopIOModel.Species) and popMean.Species/estimate=true"/>

			<connect srcID="popShapePrior.Species" targetID="prior" inputName="distribution" if="inposterior(constantPopIOModel.Species) and popShape.Species/estimate=true"/>
			<connect srcID="popMeanPrior.Species" targetID="prior" inputName="distribution" if="inposterior(constantPopIOModel.Species) and popMean.Species/estimate=true"/>

			<connect srcID="popShapeScale.Species" targetID="mcmc" inputName="operator" if="inposterior(constantPopIOModel.Species) and popShape.Species/estimate=true"/>
			<connect srcID="popMeanScale.Species" targetID="mcmc" inputName="operator" if="inposterior(constantPopIOModel.Species) and popMean.Species/estimate=true"/>

			<connect srcID="popMean.Species" targetID="updown.all.Species" inputName="down" if="inposterior(constantPopIOModel.Species) and popMean.Species/estimate=true"/>

			<connect srcID="popShape.Species" targetID="tracelog" inputName="log" if="inposterior(constantPopIOModel.Species) and popShape.Species/estimate=true"/>
			<connect srcID="popMean.Species" targetID="tracelog" inputName="log" if="inposterior(constantPopIOModel.Species) and popMean.Species/estimate=true"/>
		</subtemplate>

		<!-- Joint estimation of per-branch effective population sizes -->
		<subtemplate id="ConstantPopulations" class="starbeast2.ConstantPopulations" mainid="constPopModel.$(n)">
<![CDATA[
			<plugin id="constPopModel.$(n)" spec="starbeast2.ConstantPopulations" speciesTree="@Tree.t:Species">
				<parameter dimension="10" name="populationSizes" id="constPopSizes.$(n)" lower="0.0" value="1.0" estimate="true"/>
			</plugin>

			<distribution id="constPopSizesPrior.$(n)" spec="beast.math.distributions.Prior" x="@constPopSizes.$(n)">
				<distr spec="starbeast2.AltInverseGamma">
					<parameter name="alpha" id="constPopShape.$(n)" lower="0.0" value="3.0" estimate="false"/>
					<parameter name="mean" id="constPopMean.$(n)" lower="0.0" value="1.0" estimate="true"/>
				</distr>
			</distribution>

			<distribution id="constPopShapePrior.$(n)" spec="beast.math.distributions.Prior" x="@constPopShape.$(n)">
				<distr spec="beast.math.distributions.Uniform" lower="0.0" upper="10000.0"/>
			</distribution>

			<distribution id="constPopMeanPrior.$(n)" spec="beast.math.distributions.Prior" x="@constPopMean.$(n)">
				<distr spec="beast.math.distributions.OneOnX"/>
			</distribution>

			<operator id="constPopSizesScale.$(n)" parameter="@constPopSizes.$(n)" scaleFactor="0.5" spec="ScaleOperator" weight="3.0"/>
			<operator id="constPopShapeScale.$(n)" parameter="@constPopShape.$(n)" scaleFactor="0.75" spec="ScaleOperator" weight="1.0"/>
			<operator id="constPopMeanScale.$(n)" parameter="@constPopMean.$(n)" scaleFactor="0.75" spec="ScaleOperator" weight="1.0"/>
]]>

			<connect srcID="constPopModel.Species" targetID="popModelBridge.Species" inputName="childModel"/>
			<connect srcID="constPopModel.Species" targetID="SpeciesTreeLoggerX" inputName="populationmodel" if="inposterior(constPopModel.Species)"/>

			<connect srcID="constPopSizes.Species" targetID="state" inputName="stateNode" if="inposterior(constPopModel.Species) and constPopSizes.Species/estimate=true"/>
			<connect srcID="constPopShape.Species" targetID="state" inputName="stateNode" if="inposterior(constPopModel.Species) and constPopShape.Species/estimate=true"/>
			<connect srcID="constPopMean.Species" targetID="state" inputName="stateNode" if="inposterior(constPopModel.Species) and constPopMean.Species/estimate=true"/>

			<connect srcID="constPopSizesPrior.Species" targetID="prior" inputName="distribution" if="inposterior(constPopModel.Species) and constPopSizes.Species/estimate=true"/>
			<connect srcID="constPopShapePrior.Species" targetID="prior" inputName="distribution" if="inposterior(constPopModel.Species) and constPopShape.Species/estimate=true"/>
			<connect srcID="constPopMeanPrior.Species" targetID="prior" inputName="distribution" if="inposterior(constPopModel.Species) and constPopMean.Species/estimate=true"/>

			<connect srcID="constPopSizesScale.Species" targetID="mcmc" inputName="operator" if="inposterior(constPopModel.Species) and constPopSizes.Species/estimate=true"/>
			<connect srcID="constPopShapeScale.Species" targetID="mcmc" inputName="operator" if="inposterior(constPopModel.Species) and constPopShape.Species/estimate=true"/>
			<connect srcID="constPopMeanScale.Species" targetID="mcmc" inputName="operator" if="inposterior(constPopModel.Species) and constPopMean.Species/estimate=true"/>

			<connect srcID="constPopSizes.Species" targetID="updown.all.Species" inputName="down" if="inposterior(constPopModel.Species) and constPopSizes.Species/estimate=true"/>
			<connect srcID="constPopMean.Species" targetID="updown.all.Species" inputName="down" if="inposterior(constPopModel.Species) and constPopMean.Species/estimate=true"/>

			<connect srcID="constPopShape.Species" targetID="tracelog" inputName="log" if="inposterior(constPopModel.Species) and constPopShape.Species/estimate=true"/>
			<connect srcID="constPopMean.Species" targetID="tracelog" inputName="log" if="inposterior(constPopModel.Species) and constPopMean.Species/estimate=true"/>
		</subtemplate>

		<!-- Joint estimation of per-branch effective population sizes -->
		<subtemplate id="LinearWithConstantRootPopulations" class="starbeast2.LinearWithConstantRoot" mainid="lwcrPopModel.$(n)">
<![CDATA[
			<plugin id="lwcrPopModel.$(n)" spec="starbeast2.LinearWithConstantRoot" speciesTree="@Tree.t:Species">
				<parameter dimension="10" name="populationSizes" id="lwcrPopSizes.$(n)" lower="0.0" value="1.0" estimate="true"/>
			</plugin>

			<distribution id="lwcrPopSizesPrior.$(n)" spec="beast.math.distributions.Prior" x="@lwcrPopSizes.$(n)">
				<distr spec="starbeast2.AltInverseGamma">
					<parameter name="alpha" id="lwcrPopShape.$(n)" lower="0.0" value="3.0" estimate="false"/>
					<parameter name="mean" id="lwcrPopMean.$(n)" lower="0.0" value="1.0" estimate="true"/>
				</distr>
			</distribution>

			<distribution id="lwcrPopShapePrior.$(n)" spec="beast.math.distributions.Prior" x="@lwcrPopShape.$(n)">
				<distr spec="beast.math.distributions.Uniform" lower="0.0" upper="10000.0"/>
			</distribution>

			<distribution id="lwcrPopMeanPrior.$(n)" spec="beast.math.distributions.Prior" x="@lwcrPopMean.$(n)">
				<distr spec="beast.math.distributions.OneOnX"/>
			</distribution>

			<operator id="lwcrPopSizesScale.$(n)" parameter="@lwcrPopSizes.$(n)" scaleFactor="0.5" spec="ScaleOperator" weight="3.0"/>
			<operator id="lwcrPopShapeScale.$(n)" parameter="@lwcrPopShape.$(n)" scaleFactor="0.75" spec="ScaleOperator" weight="1.0"/>
			<operator id="lwcrPopMeanScale.$(n)" parameter="@lwcrPopMean.$(n)" scaleFactor="0.75" spec="ScaleOperator" weight="1.0"/>
]]>

			<connect srcID="lwcrPopModel.Species" targetID="popModelBridge.Species" inputName="childModel"/>
			<connect srcID="lwcrPopModel.Species" targetID="SpeciesTreeLoggerX" inputName="populationmodel" if="inposterior(lwcrPopModel.Species)"/>

			<connect srcID="lwcrPopSizes.Species" targetID="state" inputName="stateNode" if="inposterior(lwcrPopModel.Species) and lwcrPopSizes.Species/estimate=true"/>
			<connect srcID="lwcrPopShape.Species" targetID="state" inputName="stateNode" if="inposterior(lwcrPopModel.Species) and lwcrPopShape.Species/estimate=true"/>
			<connect srcID="lwcrPopMean.Species" targetID="state" inputName="stateNode" if="inposterior(lwcrPopModel.Species) and lwcrPopMean.Species/estimate=true"/>

			<connect srcID="lwcrPopSizesPrior.Species" targetID="prior" inputName="distribution" if="inposterior(lwcrPopModel.Species) and lwcrPopSizes.Species/estimate=true"/>
			<connect srcID="lwcrPopShapePrior.Species" targetID="prior" inputName="distribution" if="inposterior(lwcrPopModel.Species) and lwcrPopShape.Species/estimate=true"/>
			<connect srcID="lwcrPopMeanPrior.Species" targetID="prior" inputName="distribution" if="inposterior(lwcrPopModel.Species) and lwcrPopMean.Species/estimate=true"/>

			<connect srcID="lwcrPopSizesScale.Species" targetID="mcmc" inputName="operator" if="inposterior(lwcrPopModel.Species) and lwcrPopSizes.Species/estimate=true"/>
			<connect srcID="lwcrPopShapeScale.Species" targetID="mcmc" inputName="operator" if="inposterior(lwcrPopModel.Species) and lwcrPopShape.Species/estimate=true"/>
			<connect srcID="lwcrPopMeanScale.Species" targetID="mcmc" inputName="operator" if="inposterior(lwcrPopModel.Species) and lwcrPopMean.Species/estimate=true"/>

			<connect srcID="lwcrPopSizes.Species" targetID="updown.all.Species" inputName="down" if="inposterior(lwcrPopModel.Species) and lwcrPopSizes.Species/estimate=true"/>
			<connect srcID="lwcrPopMean.Species" targetID="updown.all.Species" inputName="down" if="inposterior(lwcrPopModel.Species) and lwcrPopMean.Species/estimate=true"/>

			<connect srcID="lwcrPopShape.Species" targetID="tracelog" inputName="log" if="inposterior(lwcrPopModel.Species) and lwcrPopShape.Species/estimate=true"/>
			<connect srcID="lwcrPopMean.Species" targetID="tracelog" inputName="log" if="inposterior(lwcrPopModel.Species) and lwcrPopMean.Species/estimate=true"/>
		</subtemplate>

        <!-- Alternatively parameterized inverse gamma -->
		<subtemplate id='AltInverseGamma' class='starbeast2.AltInverseGamma' mainid='[top]'>
			<![CDATA[
				<distr offset="0.0" spec="starbeast2.AltInverseGamma">
					<parameter name='alpha' value="3.0" estimate='false'/>
					<parameter name='mean' value="1.0" estimate='false'/>
				</distr>
			]]>
        </subtemplate>
	</mergewith>
</beast>
